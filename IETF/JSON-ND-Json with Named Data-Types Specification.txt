Independent Submission                                      Glen Kleidon
Request for Comments: <RFC number>                           Independent
Category: Experimental

            JSON-ND Syntax Rules for Encoding Data-Types 
                Within JSON Data Interchange Syntax

Abstract   

   This document describes a set of simple rules for unambigously and
   concisely encoding type information into JSON Data Interchange Syntax 
   messages.  Additionally, it provides a framework for defining complex
   data-types, methods and interfaces for static and remote services 
   using JSON syntax. These rules and framework, called the JSON-ND 
   (JSON with named data-types) Syntax, always produce valid JSON 
   messages. This means that JSON-ND can be used to address type
   safety and precision issues caused by JSON syntax limitations.
   It can be used to dynamically generate type safe objects at runtime 
   for scripting languages, eliminate interpretation error for 
   dynamically typed languages and, in a similar way to Web Service 
   Description Language (WSDL), to automatically generate service 
   ("proxy") client code for compiled lanaguages.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for examination, experimental implementation, and
   evaluation.

   This document defines an Experimental Protocol for the Internet
   community.  This document is a product of the Internet Engineering
   Task Force (IETF).  It has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are a candidate for any level of Internet
   Standard; see Section 2 of RFC 5741.

   Information about the current status of this document, any
   errata, and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc<rfc-no>.

Copyright Notice

   Copyright (c) 2020 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.

Table of Contents

1. Introduction

   JSON-ND (JSON with named data-types) is a very simple way to include 
   data-types in [JSON] data. The JSON Syntax is described in The JSON 
   Data Interchange Syntax standard [ECMA-ST-ECMA-404] 
   (http://www.ecma-international.org/publications/files/ECMA-ST/
   ECMA-404.pdf) (the JSON standard).

   JSON-ND syntax uses the "name" element of JSON value pairs to convey 
   the data-type, or in the case of unnamed or mixted type arrays, the 
   value is converted to a JSON string and the data-type is appended.

   The JSON standard, ECMA-ST-ECMA-404, paragraph 6, in conjunction with 
   [RFC8259] state that:

      A name is a string. The JSON syntax does not impose any 
      restrictions on the strings used as names, does not require that 
      name strings be unique, and does not assign any significance to 
      the ordering of name/value pairs...

   This removes the previously ambigous term "name" which, as a result 
   of an omission of a definition of the term in 2 of 3 parts of [JSON 
   Syntax](https://json.org), left the intent unclear.  The term "name"
   was described only in the text of the JSON Post, but not included in 
   the accompanying McKeeman Form or Workflow diagrams. 

   This clarified definition allows for an unambigous data-type to be 
   embedded in the name of a JSON object member and still remain legal
   JSON Syntax.

1.1.  Conventions Used in This Document

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   The grammatical rules in this document are to be interpreted as
   described in [RFC5234].

2. JSON-ND Grammar

   JSON-ND grammar is identical to that of JSON Data Interchange Syntax 
   as defined in [RFC8259] and the JSON standard [ECMA-404].  

   JSON-ND messages MAY contain embedded data-type information and MUST
   always be valid JSON.

   The inclusion of type information SHALL BE optional in all JSON-ND 
   structures.

   For the purposes of parsing JSON-ND, all JSON messages are also valid 
   JSON-ND messages as the use of embedded data-types is always 
   optional.

3. JS-ND Terms and Definitions

3.1 "Data Consumer"
   
   A "JSON-ND data consumer" SHALL BE:
      Any implementation of a computer program capable of consuming a 
      JSON-ND message. 

3.2 "Data Producer"
   
   A "JSON-ND data consumer" SHALL BE:
      Any implementation of a computer program capable of producing a 
      JSON-ND message 
  
3.2 "Data-Type"

   A "data-type" SHALL BE:

     Any text that describes how the associated value is to be 
     interpreted by the intended data consumer.
   
   This definition provides for any language syntax to describe the data
   associated with the specified data-type.  

   Because JSON-ND data-types are language dependent, when consuming a 
   JSON-ND message, the intended data consumer MUST be capable of 
   correctly interpretting the type names and the language syntax of the
   message.

   It is expected that a data consumer acting as a Web Service will 
   either use an explicit language style to which the client must 
   conform; or be capable of generating multiple versions of the same 
   message to support multiple clients implementing different language
   styles. Language styles used in this document are for example 
   purposes and should be considered informative only.
   
   As the differences between languages can be known, it is likely that
   translation services or libraries will become available to 
   automatically translate between messages of different language 
   styles.

   In the interest of interoperability, JSON-ND reserves the use of 
   three (3) keywords as data-types: "Interface", "MixedType[]" and
   "Enum".  

3.2.1 "Constant Data Type"

   The definition of a "data-type" includes any constant value such as 
   an integer, floating point number, or any other text that will be 
   understood by the data consumer to be a specific value (e.g. the 
   integer value 1).  
   
   A "constant data-type" SHALL BE:
     a data-type that should be interpretted as a specific value by the 
     data consumer. 

3.2.2  Reserved Data-Types

3.2.2.1  The "Interface" keyword

   "Interface" is a keyword used to indicate that a JSON object member
   is a data-type definition. 
    
3.2.2.2  The "MixedType[]" data-type

   "MixedType[]" is a data-type indicating that the associated value is 
   a JSON Array containing elements that MAY be of different data-type.

3.2.2.3  The "Enum" data-type

   "Enum" is a data-type that indicates the associated value is a JSON 
   array containing a list of elements intended to define an enumeration
   (or ordinal) type.

3.3 "Data-Type Qualifier"

   Data-type qualifiers are keywords with a space delimiter that MAY be 
   pre-pended to a data-type to provide additional handling 
   information for the data-type.

   JSON-ND reserves two (2) text literals as data-type qualifiers:
   "required" and "property".

   A data-type qualifier SHALL have the form:
   
     qualifier space

   where: 
     qualifier is text: either "required" or "property",
     space is the literal space character (unicode %x0020)
    
   A data-type qualifier MUST always be followed by a data-type.

   The data-type qualifier keywords MUST be in lowercase.

3.3.1  Reserved Data-Type Qualifiers 

3.3.1.1  "required"

   The keyword "required" when pre-pended to a data-type SHALL mean 
   that: 
     
     The associated value MUST be present; and
     MUST BE an allowed value of that data-type.  
   
   Non-compliance is likely to result in the value being rejected or 
   ignored by the consumer of the message.
 
3.3.1.2  "property"

   The keyword "property" when pre-pended to a data-type SHALL mean that: 
    
     In the context of a class interface definition, the consumer SHOULD
     consider the named element to be a class "property" rather than a
     class "field".

   For languages not supporting the concept of classes, an appropriate 
   language specific equivalent MAY be used or the qualifier MAY be 
   ignored.

3.4 "JSON-ND Data-Type Element"
   
   A "JSON-ND data type element" (data-type element) SHALL BE:

     a JSON string containing a "label", followed optionally by the 
     colon character (unicode %x003A), an optional data-type qualifier 
     and an optional data-type.  
  
   A JSON-ND data-type element SHALL HAVE the form:

     label [colon [<data-type qualifier>]<data-type>]

   where 
     "label" is the text used by the data consumer to refer to the 
       value associated with the label;
     "colon" (OPTIONAL) is a delimiter: the literal colon character 
       (unicode %x003A);
     "data-type-qualifier" (OPTIONAL) is a JSON-ND data-type qualifier;
     "data-type" (OPTIONAL) is the JSON-ND data-type of the element.
   
   The element MUST be enclosed by JSON quote characters.

   The colon SHOULD NOT be included if no data-type is included.

   Whitespace [ref] in a JSON-ND name SHOULD be considered as 
   significant, but significance is dependent on language style 
   interpretation.

3.5 "JSON-ND name"

   The JavaScript Object Notation (JSON) Data Interchange Format 
   [RFC8259] Section 4, describes a "JSON object" as 

    "... a pair of curly bracket tokens surrounding zero or more 
     name/value pairs."

   A JSON-ND name is equivalent to a JSON "name" in a JSON Name/Value 
   pair except that it MAY contains type information.

   RFC8259 [RFC8259] defines "name" specifically as a (JSON) "string".  
   It also refers to an object "member" as containing a (JSON) "string",
   a "name-sparator" and a (JSON) value.  Using this terminology, a 
   "JSON-ND name" (name) SHALL BE:

     a JSON-ND data-type element that replaces the JSON string in a JSON
     object member.

   For example, in the JSON-ND text:

     { "age:required integer": 23 }
   
   the text "age:required integer" is a JSON-ND Name where:
     the label is "age"
     the data-type qualifier is "required"
     the data-type is "integer".

3.6 "Default JSON-ND Array Data-Type"
   
   In the case where no specific language style is specified, the target
   language does not support array defintions sufficiently; or by 
   agreement between data consumer and data producer implementers, the 
   default JSON-ND array data-type SHOULD be used.
   
   The default "JSON-ND array Data-type" SHALL be:
     
     a JSON-ND data-type where the text representing a langauge specific
     type is followed by the Left Square Bracket (unicode %x005B), 
     then followed optionally by an integer value indicating the lower 
     bound of the array, then optionally an integer value indicating the 
     length of the array and finally by a Right Square Bracket (unicode
     %x005D)

   The form of the default JSON-ND array element SHALL BE:

     type-name lsb [[[lower-bound] comma] [length]] rsb

     where:
        "type-name" is the name of the type used in the active langauge 
         style;
        "lsb" is the literal left square bracked (unicode %x005B);
        "lower-bound" (OPTIONAL) is an integer indicating the lower 
          bound of the array;
        "comma" is the literal comma character (unicode %x002C);
        "length" (OPTIONAL) is the number of elements in the array;
        "rsb" is the literal right square bracket (unicode %x005D).

   When the lower bound is unimportant, the lower bound SHOULD be 
   omitted from the definition.

   When the number of elements is unknown, the length SHOULD be omitted 
   from the definition.

   When neither the lower bound or the length of the array is specified,
   the comma MUST be omitted from the definition.

3.7 "JSON-ND Array Element"
   
   A "JSON-ND Array Element" SHALL BE: 

     a JSON Array string value containing a JSON-ND data-type element 
     where the "label" is the string representation of a JSON Array 
     element value.

   For example, an array element of JSON boolean type having a value of
   true may be represented as the JSON-ND Array Element:

     "true:boolean".

3.8 "JSON-ND Enum Type Element"

    A "JSON-ND Enum type element" (Enum type element) SHALL BE:

     a JSON-ND data-type element where the "label" is text representing
     the ordinal type name, the data-type qualifier MUST BE omitted and 
     the (OPTIONAL) data-type MUST BE a constant data-type.  

    For examle, the following JSON-ND string:

      "dog:2" 

    is a valid Enum type element.

3.8 "Language Style Scope"
   
   JSON-ND messages may contain parts that conform to one, or to many 
   different language styles.  It is also possible to disable JSON-ND 
   processing within a message and assume JSON syntax.

   "Language Style Scope" refers to:
     
     the region of a JSON-ND message over which a particular language 
     style applies.

   For example, a message may contain parts that are expected to be 
   consumed by applications that can interpret Typescript language 
   style; other parts that are expected to be consumed by applications 
   supporting C# language style and other parts that contain JSON syntax
   only (i.e. no specific language style).

   Methods for changing scope are discussed in section <X>
   
4. Qualifying the Data-type of a JSON Object Member (name/value pair)

   In JSON-ND syntax, all JSON object member types including values, 
   objects and arrays, the JSON object member "string" SHALL be 
   replaced by a JSON-ND name.

   A JSON-ND name MAY or MAY NOT contain type information.  When no 
   type information is included in the JSON-ND name, the object member's
   JSON-ND name is identical to that of JSON "string".
   
   For example, a JSON object containing a single string MAY be 
   qualified as:

    {"name:string" : "Alice"}.

   As the data-type in a JSON-ND name is optional, the JSON text: 

    {"name": "Alice"} 

   is also valid JSON-ND syntax, where the data-type is not explicitly 
   stated (i.e. is standard JSON syntax), and therefore implictly 
   assumed to be a string.
  
5.  Qualifying the Data-Type of Array Elements

   When type information is to included in a JSON Array using JSON-ND 
   syntax, the data-type in the JSON-ND name SHOULD be defined according
   to the specified language style.

   For example in Pascal style languages, an array of 2 integer elements
   with a lower bound of 1, MAY be defined as:

     { "IntArray:integer[1..2]": [4,6] }
    
   where the range of the array is defined in the expression "1..2".

   In C style languages, the array MAY be defined similarly, except that
   the language syntax does not support lower bounds other than zero. 
   So, it MAY be sufficient to define the array as: 

     { "IntArray:int[2] : [4,6] }

   When using a C language style where the lower bound is significant, 
   an alternative approach is required.  For example:  

     1. An alternate language style MAY be temporarily specified using 
     JSON-ND scoping; or 
     2. A complex type could be defined to support the bound; or
     3. An alternate syntax may be coded into in the implementation by
     prior agreement.

   In the case where no specific language style is specified or agreed 
   in advance, either:

     1. do not include a data-type (the array is a JSON Array); or
     2. the default JSON-ND Array data-type SHOULD be used.
   
5.1 Encoding Named Arrays   
   
   A JSON array that is a JSON object member (i.e. a named JSON array) 
   MAY be encoded in one of two forms:

     1. As a JSON object Member with a qualified data-type; or
     2. As a JSON array where each element is a JSON-ND Array 
       element
   
   The first form is preferred over the second because it is less 
   verbose.
   
   When a data-type is specified, JSON Array elements MUST NOT contain a 
   data-type, EXCEPT when the data-type is the reserved data-type 
   "MixedType[]".
    
   For example, and un-bounded, string array of unknown length called
   "transport" MAY be defined as:

     "transport:string[]"    
     
   A string array containing 3 elements MAY be define as:

      "transport" : [
        "car:string",
        "boat",
        "plane:string"
      ]
   
   Note that in the example above, the element "boat" is not qualified, 
   as the data-type is optional for JSON Array elements.
  
   The "MixedType[]" data-type SHOULD be used to indicate an array 
   where the data-type of the elements are potentially different.
   Elements of an Array of "MixedType[]" MAY contain data-types 
   as described in section 5.2 (Un-Named Arrays and Arrays of 
   Mixed type).

5.2  Encoding Un-Named Arrays and Arrays of Mixed Type

   In the case where a JSON array is not a JSON Object member (i.e. an
   unnamed array), or where the array could potentially contain elements
   of mixed type, each element of the Array SHALL BE encoded as a 
   JSON-ND Array element.

   For example, an integer array element of value "27" may be encoded in 
   a JSON-ND syntax as:

    "27:integer"
  
   Assuming that a language style supporting a data-type of "Currency" 
   indicating a monetary value in a locale specific currency of 
   "dollars", an Array element of value 27 dollars MAY be encoded as:

     "27:Currency"

   An array with multiple elements MAY include a data-type for none, 
   some or all of the elements.  For example the JSON-ND text: 

    [
        "Alice:string",
        true,
        "1:currency",
        "To be\u003A Or not to be:string"
    ]

   the unambigous "boolean" value of "true" does not need to be 
   qualified so the data-type has been omitted.  
  
5.3. Encoding String Elements containing the Colon Character (%x003A).

   For un-named Arrays, arrays of MixedType[] or for named arrays with
   no explicit type, the JSON String SHALL BE encoded in one of two 
   forms where:

     1. the data-type is NOT specified, AND all colon characters (unicode 
       %x003A) being escaped using JSON encoding rules; or
     2. the data-type is specified, AND any colon characters MAY be 
        escaped using JSON encoding rules.

   In option 2 above, the data-type definition SHALL BE considered to 
   be:

      all text following the final colon in the JSON string.

   For example the string "To be: Or not to be" may be encoded as any of
   the following: 

     "To be\u003A Or not to be"

     "To be\u003A Or not to be:string" 

     "To be: Or not to be:string"
  
   However, the following sequence: 
 
     "To be: Or not to be"  

   represents a data-type of " Or not to be" with the value "To be" and  
   not a string as intended.

   For human readability, the recommended approach for encoding URIs 
   (or text where a human reader expects a colon to be present) is 
   to NOT escape the colons, but include a suitable data-type such as 
   "string" or "url" if defined.
  
   For example, the encoding:

    "http://myserver.com/api/user:url"

   is preferred over the the equally valid, but less readable form:

    "http\u003A//myserver.com/api/user".

6. Defining Data-Types

   Programming languages typically support a number of primitive 
   data-types such as integer, string, boolean and one or more floating 
   point number representations at different levels of precision. 
  
   Many languages provide for more complex types to be defined by 
   assembling collections of primitive and less complex types into 
   collections known as "lists", "structs" or "records"  and/or 
   "classes".  Most lanaguages also support a form of enumeration type 
   represented by labels that have ordinal value (e.g. Ordinal Types in 
   Pascal, and enumeration types in C style langauges).

   JSON-ND supports defining complex data types using the "Interface" 
   and "Enum" reserved data-types.

6.1 Defining Enumeration Types

   A "JSON-ND Enum type" SHALL BE:

     a named array of the reserved data-type "Enum" where each element 
     of the Array is a JSON-ND Enum type element.

   The order of the JSON-ND Enum type elements is significant except 
   when all elements contain a constant data type.

   For example, a JSON-ND Enum type representing a computer Users 
   allowed roles MAY be encoded as:

     "RoleType:Enum" :[
       "admin:1",
       "accounts",
       "sales",
       "service"
     ]

   where order of the elements is significant.  Alternatively the same
   definition MAY be encoded as:

     "RoleType:Enum" :[
       "service:4",
       "accounts:2",
       "admin:1",
       "sales:3"
     ]
   
   where the order of the elements is insignificant.
   
   In the case where a specific language style has alternative 
   convention for defining an enumeration type that can be conveyed 
   using valid JSON syntax, then the language specific form SHOULD be 
   used in preference to a JSON-ND Enum Type.

6.3 Defining Complex Data-types

   A "JSON-ND Complex Type" (complex type) SHALL BE:
     
     A JSON-ND Array of the (reserved) data-type "Interface" containing
     one or more JSON-ND Data-Type Elements where the data-type is:
       a language specific primitive data-type; or 
       one or more less complex data-types;
     and the "label" is the text used by the target language to 
     reference the associated value.

   The names and syntax of the definition of a complex Type SHALL BE 
   language style dependent, so a language style MUST be specified 
   either:
   
     explicitly within the message or witin the protocol metadata; or 
     implicitly by prior arrangement between implementors of the data
      consumer.

   Complex types MAY be defined as:
     a JSON-ND object member of data-type "Interface"; or 
     an JSON-ND Array of type Interface.

   For example, a complex type called "User" MAY be encoded using C 
   language style as:

     "User:Interface": [
       "id:int",
       "name:string",
       "roles:RoleType[]"
     ]

   The same custom type MAY be encoding using Pascal style as:

     "User:Interface": [
       "id:integer",
       "name:string",
       "roles:Array of RoleType"
     ]

   where the primitive type "id" and other (presumuably defined) 
   data-type "RoleType" form part of the complex "User" data-type.

   There SHALL BE no restriction of depth of complex types, so nested 
   data-type definitions are permitted.


7.  Defining Methods and Remote Methods (Remote Procedure Calls)

   A "JSON-ND method definition" SHALL have two forms: 

     1. a data-type form; and
     2. method-delegate form.  

   Because the JSON String type has no character format restrictions, 
   the definition of a method call can be included in a JSON string 
   exactly as it is written in target language.  The data-type form is
   simply a JSON string containing the method.

   Many lanaguages support a way to define the signature for a method 
   so that it may be treated as a data-type.  For example, this is a 
   known as "delegate" in C#, a "function pointer" in C/C++, and a
   "procedural type" or "method pointer" in Pascal.  The method-delegate
   form uses the language specific delegate syntax.
   
   The delegate form MAY be expressed in either: 
     1. "in-line" as the data-type of named element
     2. as an interface definiton.  

7.1 Remote Methods: Data Type Form

   The "JSON-ND Data-type" form for defining remote methods SHALL BE:

     a member of a JSON-ND complex type definition containing the method
     signature of a function or procedure in the syntax of a specific 
     language.

   For example, using Pascal style, a simple method for adding two 
   integers MAY be defined as part of a complex data-type:

     {
       "mathService:Interface" : [
         "function AddTwoIntegers(int1:integer; int2:integer):integer" 
       ]
     }

    For C style languages, the method MAY be defined as:

     {
       "mathService:Interface" : [
         "int AddTwoIntegers(int int1, int int2)" 
       ]
     }
    
   Note that syntax of Pascal, Kotlin and Typescript comply with the 
   JSON-ND convention that the data-type is appended after a last colon 
   in the JSON String, but the C Style languages do not.  Implementers 
   of JSON-ND in C style languages will need to take account of this 
   difference.

7.2  Remote Methods: In-line Delegate Form
   
   The in-line delegate form allows an instance of an JSON object to 
   convey a method and ANY additional information about the method such
   as it's endpoint. This approach MAY allow for a consumer to call a 
   remote method unknown at compile time.

   This form is also is especially useful when defining custom
   data-types that represent class interfaces making the definition less
   verbose and more readable.

   The in-line form for defining remote methods SHALL BE:

     a JSON-ND data-type element where the data-type is the language 
     specific signature of a method and the label is the name of the 
     method.
   
   The "Interface" data-type is not used. 

   For example, using Pascal language style, the method pointer 
   definition for a function "AddTwoIntegers" MAY be defined as: 

     Type
       AddTwoIntegers = function(int1:integer; int2:integer): integer;

   The in-line delegate form of this function MAY appear in a JSON-ND 
   message as:

     {
      "AddTwoIntegers:function(int1:integer; int2:integer):integer"
        : "https://myserver.com/api/mathService"
     }

   Language specific handling is required to implement this form and the
   syntax of the langauge may violate JSON-ND conventions with respect
   to the colon character.  For this reason, an application supporting 
   JSON-ND Remote method definitions is NOT REQUIRED support for this 
   form.

7.3  Remote Methods: Method-Delegate Form
   
   The method delegate form for defining remote methods SHALL BE:
     
   The  is defined as a type of _Interface_ and the delegate (or method pointer) form of the function is defined as a _value_.

Once defined, the method data-type, it can be included in a custom data-type:

```
 {
   "AddTwoIntegers:Interface": "function(int1:integer; int2:integer):integer",
   "mathService:Interface": [
     "addTwoIntegers:AddTwoIntegers"
   ]
 }
```
An instance of the mathService can then contain the endpoint for an implementation:
```
{
  mathService : {
    "addTwoIntegers": "./api/addtwointegers"
  }
}
```

This approach also supports multiple alternate implementations of the same method on different services:
```
 {
   "AddTwoIntegers:Interface": "int AddTwoIntegers(int int1, int int2)",

   "mathService:Interface": [
     "addTwoIntegers:AddTwoIntegers", 
     "addTwoIntegers_REST:AddTwoIntegers",
     "addTwoIntegers_AU:AddTwoIntegers", 
     "addTwoIntegers_NZ:AddTwoIntegers",
   ]
 }
```
with an example instance being:
```
{
  mathService : {
    "addTwoIntegers": "./api/addtwointegers",
    "addTwoIntegers_REST": "./api/addtwointegers/:int1/:int2",
     "addTwoIntegers_AU: "https://apis.company.com.au/api/addtwointegers",
     "addTwoIntegers_NZ": "https://apis.company.co.nz/api/addtwointegers" 
  }
}
```

### Defining Class Interfaces

It is possible to define _**Interfaces**_ that can be implemented as **_Class_** depending on the consumer language.

Many languages support classes including JavaScript as of [ES6](http://www.ecma-international.org/ecma-262/6.0/).

Take the Typescript definition below:
```
class Vendor {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  greet() {
    return "Hello, welcome to " + this.name;
  }
}
```

This can easily be represented as an interface in _in-line delegate_ form as JSON-ND as:
```
{
  "Vendor:Interface" : [
    "constructor(name: string):Vendor",
    "greet():void"
  ]
}    
```
Otherwise, in method-delegate form:
```
{
  "Greet:Interface" : "greet():void",
  "Constructor:Interface" : "constructor(name: string):Vendor",
  "Vendor:Interface" : [
    "constructor:Constructor",
    "greet:Greet"
  ]
}    
```

#### Defining interface properties
The **_property_** keyword is a modifier to define a class property.  The definition of the _getters_ and _setters_ for the property will depend upon the language.

For example, the C# interface below:
```
public interface ISampleInterface
{
    string Name
    {
        get;
        set;
    }
}
```
can be described in JSON-ND as 
```
{
   "ISampleInterface:Interface" : [
     "name:property string"
   ]
}
```
The default behaviour is to assume that both _getter_ and _setter_ are present. This is true regardless of language style. To indicate whether a property is read or write only depends on the language style.

The JSON-ND specification does not specify the exact syntax for defining getters and setters (these may be defined in future standards for language specific implementations) but suggests the following approach.

For C#, the following method-delegate form may be sufficient:
```
{
   "Name:Interface":"string name{get;set;}", 

   "ISampleInterface:Interface" : [
     "name:property Name"
   ]
}
```
For Pascal, where and interface definition must contain the method name for the getter and/or setter:
```
 Type 
   ISampleInterface = Interface
     function GetName: string;
     procedure SetName(const Value: string);
     property name: string read GetName write SetName;
   end;
```
the following form is suggested:
```
{
   "getName:Interface":"function GetName: string", 
   "setName:Interface":"procedure SetName(const Value: string)", 
   "Name:Interface":"string read getName write setName}",

   "ISampleInterface:Interface" : [
     "name:property Name"
   ]
}
```
Other languages could follow a similar approach.

In JSON-ND, **_Class_ definitions** are technically possible: however, it would require the methods implementation to be included in the definition and this is an **extreme security risk**. 

**Implementations SHOULD NOT be included in definitions** because it is extremely difficult to prevent arbitrary code from being executed in the consumer application. Scripting languages are particularly vulnerable (eg dynamic SQL and the _exec_ command in JavaScript). The inclusion of implementations for compiled languages might encourage developers to include dynamic execution methods in their applications also making them vulnerable.

## Conveying Language Style and error handling

Data consumers need to be certain of the message syntax (either JSON-ND or JSON) to ensure the data is correctly interpreted. 

JSON-ND Syntax defines 3 qualifiers for indicating the message type.

 1. "version" indicating the version of JSON-ND specification ("1.0")
 2. "style" conveys the context of data-types and method syntax (e.g. "xs", "c++", "pascal", "c#")
 3. "strict" indicator for error handling purposes.

These indicators can be conveyed to the data consumer in any way. For example:
 + out of bounds : A pre-agreement where JSON-ND version, style and strictness have been coded into the application by design
 + by using a protocol specific metadata exchange (e.g. HTTP Content-type)
 + by including a JSON-ND object within the message.

The official MIME-Type `application/json-nd` with the parameters "version", "style" and "strict".  This mime-type has preliminary registratoin with IANA and it is expected to be maintained in the future.

### Scoping JSON-ND using the JSON Object

The Scope of a language style may be restricted using then JSON-ND object.

The JSON-ND object is defined as:
```
 "Json-ND" :{ 
  "version": 1.0, 
  "style": "<language>", 
  [,"strict": true|false] 
  [, "data":{}]
}
```
This allows messages to contain multiple definitions and/or data in different language styles. For example:

```
{
  "Json-ND" :{ 
    "version": 1.0, 
    "style": "pascal", 
    "data":{
      "Vendor:Interface" : [
        "constructor Create(name: string)",
        "procedure greet"
      ] 
    }
  },
  "Json-ND" :{ 
    "version": 1.0, 
    "style": "C#", 
    "strict": true, 
    data:{
      "Vendor:Interface" : [
        "Vendor(string name)",
        "void greet()"
      ] 
    }
  }
}
```

6.4 Handling Optional and Required Data Elements
   
   Any data-type not explicitly including the "required" data-type 
   qualifier is assumed to be optional.  A JSON-ND parser MUST NOT 
   evoke error handling in the absence or 
   
   The data-type qualifier "required" indicates to a data producer that 
   an instance of the associated value MUST always be populated with a 
   valid quantity.  A data consumer SHOULD consider that unpopulated or
   invalid quantity is incorrect and appropriate error handling should 
   take place.
   
   For example:
  
     a web service acting as a data consumer, exposes a function 
     "UpdateUser" which must have a valid value of "id" to correctly 
     handle a request.  
   
     The "User" data-type MAY be defined as:

       "User:Interface": [
         "id:required int",
         "name:string",
         "roles:RoleTypes[0,]"
       ]
    
   If a service client, acting as a data producer, attempted to send a 
   a request to the function containing the JSON object:

     "User" : {
       "name" : "Alice",
       "roles": [sales]
     }

   the service is likely to send a "Bad Request" response indicating 
   that the request is invalid.



The only allowed value of _**version**_ is currently "1.0". 

The _**style**_ property is a string value that indicates a programming language or specification where data-types and/or method syntax are defined. Any string may be used here to sufficiently disambiguate all data-types and method syntax used within the message.

The _**strict**_ property indicates that non-conformant messages should be rejected.  Where the strict property is not used (or set to false) then no error message should be generated by the parsing process, however it may be that a method may still fail during processing.

### Error handling (_strict_ Indicator)
The introduction of typing in JSON-ND introduces the need for error handling because there is a potential for data to be incompatible with the definition.

The default action when parsing JSON-ND syntax for unknown properties, non-conformant values, or misalignment of range bounds in Arrays is to **ignore data and adhere the specified type**.  For example: the following non-conformant message: 
```
{"name:string": true, "items:integer[0,2]" : "[3,2.5,7]" } 
```
should be interpretted as: 
```
{"name:string": null, "items:integer[0,2]" : "[3,<default||null>]" } 
```
and the consumer should attempt to use the interpreted data as supplied. 

When the JSON-ND _strict_ qualifier is used (either unqualified or set to "true") then the entire message transaction above should be rejected as an error.

For Example using a Scoped JSON-ND Object: 
```
 "Json-ND" :{ 
  "version": 1.0, 
  "style": "pascal", 
  "strict": true, 
  "data":{
      "id:required integer": null,
      "age:integer": "old",
   }
}
```
should result in an exception being raised and error handling to be evoked.  This applies equally an entire message using the JSON-ND mime-type, for example in the http request:
```
GET /api/user HTTP/1.1
Content-Type: application/json-nd; version=1.0; style="pascal"; strict

{
  "id:required integer": null,
  "age:integer": "old"
}
```
The receiving server should reject the message as a `400 Bad Request` as the required Identifier "id" is not supplied and the integer element "age" is not an integer.



8.  IANA Considerations

  The media type for JSON-ND text is application/json-nd.

   Type name:  application

   Subtype name:  json-nd

   Required parameters:

   Optional parameters: version; style; strict;

   Encoding considerations:  binary

   Security considerations:  These are Idential to JSON, See RFC 8259,
    Section 12.

   Interoperability considerations: These are identical to JSON as 
    Described in RFC 8259.

   Published specification:  

   Applications that use this media type:
      A limited number of demonstration applications have used JSON-ND 
      Syntax, however, as JSON-ND is a superset of JSON, it has the 
      potential to exchange data between any applications currently 
      capable of using JSON Syntax and any future applications that
      could potentially support JSON Syntax. 

   Additional information:
      Magic number(s): n/a
      File extension(s): .jsonnd
      Macintosh file type code(s): TEXT

   Person & email address to contact for further information:
      glen Kleidon
      <gk@galkam.com.au>

   Intended usage:  COMMON

   Restrictions on usage:  none

   Author:
      Glen Kleidon
      <gk@galkam.com.au>

   Change controller:
      Glen Kleidon
      <gk@galkam.com.au>

  
11.  Security Considerations
  The security considerations for JSON-ND are essentially identical to 
  those of JSON Syntax: See RFC 8259, Section 12.

  It is noteworthy that because JSON-ND allows for remote methods to be
  defined and also for Interfaces to carry method definitions, that the
  risk of JSON-ND consumers executing arbitrary code conveyed in a 
  JSON-ND message may be high than that of JSON syntax where the 
  language supports that feature (eg "eval()" in Javascript or 
  variations of the "exec" method in SQL implementations).

10.  References
123456789012345678901234567890123456789012345678901234567890123456789012
  10.1.  Normative References

  10.2.  Informative References
  Appendix A.
  Appendix B.

Acknowledgements
  
  I must acknowledge Anders Heljlsberg and the Typescript team at 
  Microsoft who's work on Typescript inspired the principles of JSON-ND
  particularly with respect to the default formatting and the idea of
  Super-Set of a work could extend its functionality without 
  fundamentally changing it. 

Contributors

  This document was written by Glen Kleidon.

Author's Address
   
   Glen Kleidon (Author)
   Galkam Pty Ltd

   Email: gk@galkam.com.au
